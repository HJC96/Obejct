# CH.6 메세지와 인터페이스

‘메시지와 인터페이스'에서는 훌륭한 퍼블릭 인터페이스를 작성하기 위해 따라야 하는 설계 원칙을 소개한다. 디미터 법칙, 묻지 말고 시켜라, 의도를 드러내는 인터페이스, 명령-쿼리 분리 원칙을 조합하면 직관적이고, 예측 가능하며, 유명한 퍼블릭 인터페이스를 창조할 수 있다는 사실을 알게될 것이다.

### 협력과 메시지

**클라이언트 - 서버 모델**
- 메시지를 전송하는 객체: 클라이언트
- 메시지를 수신하는 객체: 서버

이때, 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 **동시에 수행**하는 것이 일반적이다.

**용어정리**
- **메시지**: **오퍼레이션명**과 **인자**로 구성됨. 여기에 수신자를 추가하면, 메시지 전송
  - isSatisfiedBy(screening): 메시지
  - **condition**.isSatisfiedBy(screening): 메시지 전송
- **메서드**: 실제로 실행되는 함수 또는 프로시저. 이때, 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송해도 객체의 타입에 따라 메서드가 달라질 수 있다.(객체 내부에서 다르게 정의되어서)
- **퍼블릭 인터페이스**: 객체는 가려져있지만, 의사소통을 위해 외부에 공개하는 메시지의 집합
- **오퍼레이션**: 퍼블릭 인터페이스에 포함된 메시지, 메시지와 관련된 시그니처를 가르키는 경우가 대부분.
- **시그니처**: 오퍼레이션의 이름과 파라미터 목록을 합친 것. 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것. 메서드는 이 시그니처에 구현을 더한 것.

### (코드 예제)
~~~java
// ✅ 퍼블릭 인터페이스: 외부에 노출된 오퍼레이션(시그니처)들의 집합
public interface Greeter {
    // ✅ 오퍼레이션(Operation): 객체가 응답할 수 있도록 인터페이스에 선언된 동작
    // → 오퍼레이션은 시그니처(Signature)로 표현됨
    // ✅ 시그니처(Signature): 메서드 이름 + 파라미터 목록 (리턴 타입은 포함 X)
    void greet(String name); // 오퍼레이션 선언 (greet + (String))
}


// ✅ 오퍼레이션을 실제로 구현한 클래스 (메서드 포함)
public class KoreanGreeter implements Greeter {

    // ✅ 메서드(Method): 오퍼레이션의 실제 구현체 (실행 가능한 코드 포함)
    @Override
    public void greet(String name) {
        System.out.println("안녕하세요, " + name + "님!");
    }
}

public class EnglishGreeter implements Greeter {
    @Override
    public void greet(String name) {
        System.out.println("Hello, " + name + "!");
    }
}
~~~


오퍼레이션(시그니처)으로 사용된 isSatisfiedBy
```java
public interface DiscountCondition {
	boolean isSatisfiedBy(Screening screening);
}
```

메서드로 사용된 isSatisfiedBy
```java
public class SequenceCondition implements DiscountCondition {

private int sequence;
	public SequenceCondition(int sequence) {
		this.sequence = sequence;
	}
	public boolean isSatisfiedBy(Screening screening) {
		return sequence == screening.getSequence();
	}
}
```

### 인터페이스와 설계 품질

좋은 인터페이스 = 최소한의 인터페이스 + 추상적인 인터페이스
최소한의 인터페이스 = 꼭 필요한 오퍼레이션만을 인터페이스에 포함하는 것.
추상적인 인터페이스 = 어떻게 수행하는지가 아니라 **무엇을 하는지 표현**하는 것
최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법 => 책임 주도 설계 방법

왜?
1. 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지하기 때문.
2. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 클라이언트의 의도가 메시지에 표현되어 추상적인 오퍼레이션이 자연스럽게 스며든다.

다음과 같은 원칙과 기법이 있다.
1. 디미터 법칙
2. 묻지 말고 시켜라
3. 의도를 드러내는 인터페이스
4. 명령-쿼리 분리

**디미터 법칙**이란?
협력하는 객체의 내부 구조에 대한 **결합으로 인해 발생하는 설계 문제**를 해결하기 위해 제안된 원칙.

객체의 내부구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것, 자바나 C# 같이 도트를 이용해 메시지 전송을 표현하는 언어에서는 “오직 하나의 도트만 사용하라”는 말로 요약되기도 한다.

모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다. 이때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다.

- M의 인자로 전달된 클래스(C 자체를 포함)
- C의 인스턴스 변수의 클래스

위 설명이 어렵다면 아래를 참조하라. 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다라고 이해.

1. This 객체
2. 메서드의 매개변수
3. this의 속성
4. this의 속성인 컬렉션의 요소
5. 메서드 내에서 생성된 지역객체

**디미터 법칙을 따랐을때 효과**
디미터 법칙을 따르면 부끄럼타는 코드(shy code)를 작성할 수 있다. 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.

**디미터 법칙 <—> 캡슐화**
디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 디미터 법칙이 가치 있는 이유는 클래스를 캡슐화하기 위해 따라야하는 구체적인 지침을 제공하기 때문이다. **캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한.** 디미터 법칙은 협력과 구현이라는 사뭇 달라 보이는 **두 가지 문맥을 하나의 유기적인 개념**으로 통합한다. 클래스의 내부 구현을 채워가는 동시에 현재 협력하고 있는 클래스에 관해서도 고민하도록 주의를 환기시키기 때문이다.(디미터 법칙: 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 하는 것)

**디미터 법칙을 위반하는 코드**
screening.getMovie().getDiscountConditions();

메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환 받은 요소에 대해 연쇄적으로 메시지를 전송한다. 이와 같은 코드를 **기차 충돌**이라고 부른다. => 내부 구현이 외부로 노출

**디미터 법칙을 따르는 코드**
screening.calculateFee(audienceCount);

디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조. 하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 **객체의 응집도가 낮아질 수도 있다**.

**묻지 말고 시켜라**
앞에서 Screening 내부의 Movie에 접근하는 대신 Screening에게 직접 요금을 계산하도록 요청했다. 요금을 계산하는데 필요한 정보를 잘 알고 있는 Screening에게 요금을 계산할 책임을 할당한 것이다. => 묻지말고 시켜라

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다. 여러분이 구현하고 있는 로직은 메시지 수신자가 담당해야할 책임일 것.

묻지말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 이 원칙을 따르도록 메시지를 결정하다 보면 **자연스레 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스**를 얻을 확률이 높아진다.

하지만 단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다. 훌륭한 인터페이스를 수확하기 위해서는 객체가 **어떻게 작업을 수행하는지를 노출해서는 안 된다. 인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지**를 서술해야한다.

**의도를 드러내는 인터페이스**
메서드를 명명하는 두 가지 방법

첫 번째, 메서드가 작업을 **어떻게 수행**하는지를 나타내도록 이름 짓는 것

예)

```java
public class PeriodCondition{
	public bollean isSatisfiedByPeriod(Screening screening){...}
}

public class SequenceCondition{
	public bollean isSatisfiedBySequence(Screening screening){...}
}
```

이 스타일이 좋지 않은 이유 두 가지.
1. isSatisfiedByPeriod와 isSatisfiedBySequence 모두 할인 조건을 판단하는 **동일한 작업을 수행**하지만, 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 **두 메서드가 동일한 작업을 수행한다는 사실을 알아채기 어렵다**.
2. 메서드 수준에서 캡슐화를 위반한다는 것이다. 만약 할인 여부를 판단하는 방법이 변경된다면 메서드의 이름 역시 변경해야할 것이다.. 메서드 이름을 변경한다는 것은 메시지를 전송하는 클라이언트 코드도 함께 변경해야한다는 것을 의미한다. **따라서, 변경에 취약하다.**

두 번째, 메서드가 **어떻게가 아닌 무엇**을 하는지 드러내는 것. 메서드의 구현이 한 가지인 경우에는 무엇을 하는지를 드러내는 이름을 짓는 것이 어려울 수도 있다. 하지만 **무엇을 하는지를 드러내는 이름은 코드**를 읽고 이해하기 쉽게 만들 뿐만 아니라 유연한 코드를 낳는 지름길이다. 

예)

```jsx
public class PeriodCondition{
	public bollean isSatisfiedBy(Screening screening){...}
}

public class SequenceCondition{
	public bollean isSatisfiedBy(Screening screening){...}
}
```

변경된 코드는 PeriodCondition의 isSatisfiedBy 메서드와 SequenceCondition의 isSatisfiedBy 메서드가 동일한 **목적을 가진다는 것을 메서드의 이름을 통해 명확**하게 표현한다.

클라이언트가 두 메서드를 가진 객체를 동일한 타입으로 간주할 수 있도록 **동일한 타입 계층으로 묶자**.

```jsx
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```

DiscountCondition 인터페이스를 실체화하게 하면 클라이언트 입장에서 두 메서드를 동일한 방식으로 사용할 수 있게 됨,

```jsx
public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy (Screening screening) { ... }
}

public class SequenceCondition implements DiscountCondition {
    public boolean isSatisfiedBy (Screening screening) { ... }
}
```

이처럼 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 **의도를 드러내는 선택자(Intention Revealing Selector)**라고 부른다.


### 인터페이스에 의도를 드러내자
~~~java
public void setTicket(Ticket ticket);
~~~
이렇게 이름 지으면 얘가 무슨일을 하는지 알 수 있을까?

~~~java
public Long buy(Ticket ticket);
~~~
이런식으로 이해할 수 있게 변경하면 클라이언트의 의도를 좀 더 분명하게 표현할 수 있을 것이다.


### 원칙의 함정

- 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.    
  ```jsx
  IntStream.of(1,15,20,3,9).filter(x->x>10).distinct().count()
  ```
  디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다. 
  기차 코드를 본다면 스스로 다음과 같은 질문을 하기 : 여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는가? 즉, **디미터 법칙 잘 지켜짐.**
    
- 결합도와 응집도의 충돌
- ~~~java
  // 이 코드는 응집도는 높으나 결합도가 높고
  public boolean isSatisfiedBy(Screening screening){
    return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) && ...
  }
  
  // 이 코드는 응집도는 낮으나 결합도가 낮다. (응집도가 낮다는건 screening이 할인을 판단하는 책임도 지기 때문에.)
  public boolean isSatisfiedBy(Screening screening){
    return screening.isDiscountable(...);
  }
  
  ~~~
  디미터 법칙의 위반 여부는 묻는 대상이 객체(숨김)인지, 자료구조(노출)인지에 달려있다.
  객체에게 시키는 것이 항상 가능한 것은 아니다. 가끔은 물어야한다.
    
### 명령-쿼리 분리 원칙

> 명령-퀴리 분리(Command-Query-Separation)
**질문이 답변을 수정해서는 안된다.** 
오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다.
what? 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공
명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질수 있다. 버그를 찾기 어렵고 버그를 양산하는 경향이 있다. 
명령 쿼리 분리 원칙을 잘 지키면,  코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다.
> 

**루틴(routine)** : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
루틴은 아래 두가지로 분류한다.
- 프로시져(procedure): **부수효과**를 발생시킬 수 있지만 값을 반환할 수 없다. 
  - 개념적으로 Command와 같다.
- 함수(function): **값을 반환**할 수 있지만 부수효과를 발생 시킬 수 없다.
  - 개념적으로 Query와 같다.

**명령과 쿼리를 분리해서 얻게 되는 장점은 무엇인가?** 
예를들어 isSatisfied가 명령과 쿼리 두가지 역할을 수행하고 있다면, 해당 메소드를 수행할때마다 결과가 바뀔수 있기 때문에 예측 불가능한 코드가 된다. 이는 디버깅이 어려워지고 유지보수가 어려워지게 됨을 야기한다.

### 메세지와 인터페이스
휼륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다. 여기서 중요한 것은 책임이 객체가 수신할 수 있는 메세지의 기반이 된다는 것이다.
객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메세지다. 애플리케이션은 클래스로 구성되지만 메세지를 통해 정의된다는 사실을 기억하라
1. 협력과 메세지
   1. 클라이언트-서버 모델
      협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다. 메세지는 객체 사이의 협력을 가능하게 하는 매개체다. 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메세지를 전송하는 것뿐이다.
      메세지 = 오퍼레이션명 + 인자
원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다. 198
디미터 법칙 - **객체의 내부 구조를 노출시키지 않고** 오직 하나의 도트만 사용하라

### 참조투명성
참조투명성을 만족하는 식은 우리에게 두 가지 장점을 제공한다.
1. 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
2. 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.

객체지향 패러다임이 객체의 상태 변경이라는 **부수효과**를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다. 하지만 명령-쿼라 분리 원칙을 사용하면 이 균열을 조금이나마 줄일 수 있다.

### 명령형 프로그래밍 vs 함수형 프로그래밍
| **기준** | **명령형 프로그래밍** | **함수형 프로그래밍** |
|:-:|:-:|:-:|
| **부수 효과(Side Effect)** | ✔ 허용하고 적극 사용함 | ❌ 최소화하거나 완전히 제거하려 함 |
| **상태 변경** | ✔ 변수 값 변경, 루프 사용 등 흔함 | ❌ 상태 변경 대신 *불변성(immutability)* 사용 |
| **제어 흐름** | 명령어 순서대로 실행 (for, if, while) | 선언적으로 map, filter, reduce 등 사용 |
| **참조 투명성** | ❌ 깨지기 쉬움 (동일 표현식이 항상 같은 결과 X) | ✅ 유지하려고 노력함 |
| **예시 코드 스타일** | for, if, 변수 += | List.map().filter().reduce() |
1. 명령형 스타일
~~~java
int sum = 0;
for (int i = 1; i <= 5; i++) {
    sum += i;
}
System.out.println(sum); // 부수 효과: sum이라는 외부 변수 변경
~~~
   
2. 함수형 스타일
~~~java
int sum = IntStream.rangeClosed(1, 5)
                   .sum();
System.out.println(sum); // sum은 불변 변수. 내부 상태 변경 없음
~~~

