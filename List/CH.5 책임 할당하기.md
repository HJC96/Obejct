
# 책임 할당하기
‘책임 할당하기'에서는 GRASP라고 부르는 책임 할당 패턴을 설명한다. 2장에서 소개한 영화 예매 시스템의 설계를 책임 할당의 관점에서 설명하고 4장에서 구현된 절차적 프로그래밍 방식과 비교한다. 5장을 읽고 나면 책임을 중심으로 설계를 이끌어가는 것이 캡슐화, 응집도, 결합도의 관점에서 설계를 개선한다는 사실을 이해하게 될 것이다.

## 책임 주도 설계를 향해

책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 **어떤 객체에게 어떤 책임**을 할당할지 결정하기 쉽지 않다는 것. 하지만 데이터에 초점을 맞추고 설계를 하면 **캡슐화가 약화**되기 때문에 **낮은 응집도**와 **높은 결합도**를 가진 객체들로 넘쳐나게 된다 ⇒ 변경에 취약한 설계를 얻게 됨.  

- 객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동.
- 객체가 수행하는 행동이란 곡 객체의 책임을 의미.

## 설계방법

책임(행동)을 먼저 결정한 후에 객체의 상태(데이터)를 결정 => 협력에서 어떤 객체에 어떤 책임을 할당할지 결정 할 수 있다.

**협력이라는 문맥 안에서 책임을 결정하라**

- 책임의 품질은 협력에 적합한 정도 ⇒ 객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁨

그렇다면 협력에 적합한 책임은? **메시지 전송자**에게 적합한 책임

우리가 해야할 질문: 클래스 결정 => 클래스 책임 찾기 (x) 메시지 결정 => 메시지 누구에게 전송할지 찾기(o)

주목해야 할 점 두 가지

1. 메시지가 클라이언트(메시지 전송 측)의 의도를 표현
2. 객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정한다

**책임 주도 설계**

1. 시스템이 사용자에게 제공해야 하는 기능인 **시스템 책임**을 파악
2. **시스템 책임**을 **더 작은 책임**으로 분할
3. 분할된 책임을 수행할 수 있는 **적절한 객체** 또는 **역할을 찾아 책임을 할당**
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요할 경우 이를 책임질 **적절한 객체 또는 역할을 찾음**
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 **협력**하게 한다.

## 책임 할당을 위한 GRASP 패턴

**도메인 개념에서 출발하기**

어떤 책임을 할당해야 할 때 가장 먼저 고려해야 하는 유력한 후보는 **도메인 개념**

- 설계의 출발점이 된다.
- 모델을 기반으로 코드 작성, 하지만 코드에 의해 모델이 변경되기도 함 ⇒ 유기적
- 올바른 도메인 모델은 없으니 빠르게 구현

**정보 전문가에게 책임을 할당하라**

**높은 응집도와 낮은 결합도**

- 설계는 트레이드오프 활동 ⇒ 책임 할당을 INFORMATION EXPERT에 하지 않을 수도…
- 그렇다면 무엇을 기준으로 설계를 하냐? LOW COUPLING, HIGH COHESION

**LOW COUPLING**

- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하는 것.

Screening에 Discount Condition을 할당하지 않고, Movie에 할당

**HIGH COHESION**

- 높은 응집도를 유지할 수 있게 책임을 할당하는 것.

Screening이 Discount Condition과 협력한다면 영화 요금 계산과 관련된 책임 일부를 떠안을 것이므로 응집도가 낮아짐.

한편, Movie가 DiscountCondition과 협력하는 것은 응집도에 아무 영향 없음.

**창조자에게 객체 생성 책임을 할당하라**

영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것. 그럼 누가 인스턴스를 생성할 책임을 지는가? 창조자 패턴 이용.

**CREATOR 패턴**

CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 **관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것**이다. 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다. 다시 말해서 두 객체는 서로 결합된다. => 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다. 결과적으로 CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다.

아래 조건을 가장 많이 만족하는 B에게 객체 생성 책임을 할당.

1. B가 A 객체를 포함하거나 참조한다.
2. B가 A 객체를 기록한다
3. B가 A 객체를 긴밀하게 사용한다
4. B가 객체를 초기화하는 데 필요한 데이터를 가지고 있다 (이 경우 B는 A에 대한 정보 전문가다)

객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?

## 구현을 통한 검증

역할의 구현 2가지 방법

- 추상클래스 : 책임의 일부를 구현해 놓은 것
- 인터페이스 : 책임의 집합만 나열해 놓은 것

클래스 응집도 판단하기

- 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 서로 연관성 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐있기 때문에.. → 변경의 이유를 기준으로 분리하라
- 클래스의 인스턴스가 초기화 하는 시점에 경우에 따라 서로 다른 속성들을 초기화 하고 있다면 응집도가 낮은 것이다. →  초기화 되는 속성의 그룹을 기준으로 클래스를 분리하라
- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. → 이들 그룹을 기준으로 클래스를 분리하라.

ex) 타입 분리하기 → 설계의 관점에서 전체적인 결합도 증가 → 다형성을 통해 분리하기

POLYMORPHISM(다형성)패턴 ?

객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하는 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하는 패턴 

RPOTECTED VARIATIONS(변경 보호)패턴?

변경을 캡슐화

## 책임 주도 설계의 대안

책임 주도 설계에 익숙해지기 위해서는 부단한 노력과 시간이 필요함. 하지만 어느 정도 경험을 쌓은 숙련된 설계자 조차도 적절한 책임과 객체를 선택하는 일에 어려움을 느낌..

→ 대안.. 일단 최대한 빠르게 목적한 기능을 수행하는 코드를 작성해 보기 그 후에 **리펙토링**

1. 목적한 기능을 수행하는 코드 작성
2. 큰 메세드를 응집도 높은 작은 메서드로 변경
3. 2번에서 또 관련있는 것들끼리 따로 클래스로 만들기   
    메서드를 이동할 때 캡슐화, 응집도, 결합도의 측면에서 이동시키기
