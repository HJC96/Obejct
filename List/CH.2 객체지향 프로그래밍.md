‘객체지향 프로그래밍’에서는 책 전반에 걸쳐 반복적으로 참고하게 될 영화 예매 시스템의 도메인을 설명하고 객체지향적으로 작성한 코드를 소개한다. 2장을 읽고 나면 객체지향 프로그래밍에서 사용되는 다양한 요소와 개념도 함께 이해하게 될 것이다.

## 객체지향 프로그래밍 - 객체에 초점을 맞추라

1. 어떤 클래스를 고민하기보다, 어떤 객체들을 고민하라
    1. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이기 때문에, 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정해야한다.
2. 객체를 자율적 협력자로 보고, 1을 바탕으로 클래스 구성
    1. 객체를 공동체의 일원으로 봄으로써 설계를 유연하고 확장 가능하게 만든다.

### 도메인 
문제 해결을 위해 프로그램을 사용하는 분야, 도메인을 구현하기 위해 객체, 클래스 사용

ex) 영화 예매 도메인

### 클래스 구현시 중요한 점
클래스 내부와 외부를 구분하는 것

=> 경계의 명확성이 자율성을 보장, 프로그래머에게 구현의 자유를 보장

## 자율적인 객체
- 객체가 상태와 행동을 함께 가지는 복합적인 존재
- 객체 스스로가 판단하고 행동하는 자율적인 존재

## 패러다임

### 객체지향 이전 
데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구성

### 객체지향
객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음(캡슐화)으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 했다.
대부분의 객체지향 프로그래밍은 캡슐화에서 더 나아가 접근 제어 메커니즘도 함께 제공한다. 많은 프로그래밍 언어들은 접근 제어를 위해 public, protected, private과 같은 접근 수정자를 제공한다.
캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 하나는 외부에서 접근 가능한 부분으로 이를 **퍼블릭 인터페이스**라고 부른다. 다른 하나는 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현**이라고 한다.
일반적으로 **객체의 상태는 숨기고 행동만 외부에 공개해야** 한다.

### 프로그래머의 역할

- 클래스 작성자: 새로운 데이터 타입을 프로그램에 추가
- 클라이언트 프로그래머: 클래스 작성자가 추가한 데이터 타입을 사용한다.

클라이언트 프로그래머의 목표: 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축

### 클래스 작성자 
클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨김.

### 구현 은닉 
클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

구현 은닉의 장점

- 클라이언트 프로그래머: 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.
- 클래스 작성자: 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. 다시 말해 public 영역을 변경하지 않는다면, 코드를 자유롭게 수정할 수 있다는 것이다.

### 협력

- 객체가 다른 객체와 상호작용하는 방법: 메시지 송, 수신
- 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부른다.

### 오버라이딩과 오버로딩

#### 오버라이딩
부모 클래스에 정의된같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의 하는 경우

#### 오버로딩
메서드의 이름은 같지만 제공되는 파라미터의 목록이 다름

### 의존성

어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다.
코드 수준에서 Movie 클래스는 DiscountPolicy에 의존하지, AmountDiscountPolicy 혹은 PercentDiscountPolicy 이 두 클래스 중 어떤것에도 의존하지 않는다.
이것이 가능한 이유: 코드 의존성과 실행 시점의 의존성이 서로 다르기 때문.

- 코드 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
- 코드 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 유연하고 확장가능하다.
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 어려워진다.
- 유연성을 억제하면 재사용성과 확장 가능성은 낮아진다.

이처럼 자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅**이라고 부른다.

### 다형성

컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해, 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수있는 능력을 의미한다.

지연 바인딩, 동적 바인딩: 메시지와 메서드를 실행 시점에 바인딩하는 것.

초기 바인딩, 정적 바인딩: 전통적인 함수 호출처럼, 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것

### 상속

- 구현 상속: 서브클래싱, 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
- 인터페이스 상속: 서브타이핑, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 고유할 수 있도록 상속을 이용한는 것.

많은 사람들이 코드 재사용을 상속의 주된 목적이라고 생각하지만, 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.

추상화: 이렇게 데이터나 프로세스를 의미, 수행과정이 비슷한 개념으로 묶어 정의(선언)하는 것(Dog, Cat -> Pet)

ㅁ-> ㅁ-> ㅁ

1. 세부적인 내용은 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
2. 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

### **합성**

Movie는 요금을 계산하기 위해 DiscountPolicy의 코드를 재사용한다. 상속과 다른점은 상속이 부모클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 데 비해 Movie가 DiscountPolicy의 인터페이스를 통해 약하게 결합된다는 것이다.

합성은 상속이 가지는 두 가지 문제점을 모두 해결한다. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
