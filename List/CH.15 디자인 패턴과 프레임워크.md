# CH.15 디자인 패턴과 프레임워크

**디자인 패턴이란?**

소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 한다.

**프레임워크란?**

디자인 패턴이 설계를 재사용하기 위한 것이라면 **프레임워크**는 **설계와 코드를 재사용**하기 위한 것

|  | 목적 | 제공 |
| --- | --- | --- |
| 디자인 패턴 | 협력을 일관성 있게 만들기 위함 | 특정한 변경을 일관성 있게 만들기 위한협력 템플릿 |
| 프레임 워크 | 협력을 일관성 있게 만들기 위함 | 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿 |

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

**패턴의 몇 가지 핵심적인 특징**

- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

**패턴언어와 패턴 시스템**

- 패턴은 홀로 존재하지 않고 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있으며 패턴들을 포함하는 더 큰 패턴 내에 통합될 수 있다.
- 연관된 패턴들의 집합들이 모여 하나의 **패턴 언어를 구성한다고 정의**하고 있다.
- 패턴 언어라는 용어가 지닌 제약조건을 완화하기 위해 **패턴 시스템**이라는 특수한 용어의 사용을 제안하기도 했으나 현재 두 용어는 거의 동일한 의미로 사용되고 있다.

**패턴 분류**

패턴의 범위나 적용단계에 따라 4 가지로 분류한다.

1. 아키텍쳐 패턴
    1. 디자인 패턴의 상위에 **소프트웨어의 전체적인 구조**를 결정하기 위해 사용하는 패턴
    2. 미리 정의된 서브시스템들을 제공하고 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
2. 분석 패턴
    1. 분석 패턴은 도메인 내의 **개념적인 문제를 해결하는데 초점**을 맞춘다.
    2. 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이며 단 하나의 도메인에서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수 있다.
3. 디자인 패턴
    1. 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.
    2. 중간 규모의 패턴으로 특정한 설계 문제를 해결하는 것을 목적으로 하며 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
4. 이디엄
    1. 디자인 패턴의 하위에 위치하며 **특정** 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.
    2. 주어진 언어의 기능을 사용해 컴포넌트 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술
    3. 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
        1. C++ COUNTER POINTER 이디엄은 가상 머신이 참조되지 않는 객체를 자동으로 삭제하는 가비지 컬렉션 메커니즘을 가진 자바에서는 유용하지 않다.

**패턴과 책임-주도 설계**

객체지향 설계에서 가장 중요한 일은 **올바른 책임을 올바른 객체에게 할당**하고 **객체 간의 유연한 협력 관계를 구축**하는 일이다.

패턴은 공통으로 사용할 수 있는 **역할, 책임, 협력의 템플릿**이다. 패턴은 **반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공**한다.

→ 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다.

패턴의 구성 요소는 클래스가 아닌 ‘역할’이다. 클라이언트가 **개별 객체**와 **복합 객체**를 동일하게 취급할 수 있는 **COMPOSITE 패턴**을 살펴보자

- Component, Composite, Leaf는 클래스가 아닌 협력에 참여하는 객체들의 역할
- Component는 역할이기 때문에 Component가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 Component의 역할을 수행할 수 있다.

<img width="733" alt="Untitled" src="https://github.com/HJC96/Obejct/assets/87226129/03867c54-efcd-48b9-8ef7-b3b452cba577">


- 역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기 때문에 다음 그림과 같이 하나의 객체가 세 가지 역할 모두를 수행하더라도 문제가 없다.
<img width="649" alt="Untitled 1" src="https://github.com/HJC96/Obejct/assets/87226129/afcafb63-2b11-4c41-9e1f-41149e64a046">



반대로 다수의 클래스가 동일한 역할을 구현할 수 있다. 다음 그림은 중복 할인 설계의 기본 구조이며 COMPOSITE 패턴을 따른 것이다.

- OverlappedDiscountPolicy는 Composite의 역할을 수행하고 AmountDiscountPolicy와 PercentDiscountPolicy가 동일한 Leaf라는 역할을 수행한다.
<img width="652" alt="Untitled 2" src="https://github.com/HJC96/Obejct/assets/87226129/3c7f0f04-e2b0-48f2-8487-30a779e095e0">



→ 그림 15.2와 15.3은 모두 올바른 COMPOSITE 패턴이다. 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것 역시 중요하다.

**캡슐화와 디자인 패턴**

대부분의 디자인 패턴은 **협력을 일관성 있고 유연하게 만드는 것을 목적**으로 한다. 따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.

영화 예매 시스템에서 Movie가 DiscountPolicy 상속 계층을 합성 관계로 유지해야 하는 다양한 설계 원칙과 이유에 대해 장황하게 설명했지만 사실 이 설계는 **STRATEGY 패턴을 적용한 예**다. **STRATEGY 패턴의 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용**한다.

그림 15.4는 STRATEGY 패턴을 적용한 영화 예매 시스템 설계를 표현한 것이다. 영화에 적용될 할인 정책의 종류는 Movie가 참조하는 DisocuntPolicy의 서브 클래스가 무엇이냐에 따라 결정된다. 그리고 **STRATEGY 패턴**을 이용하면 Movie와 DiscountPolicy 사이의 결합도를 낮게 유지할 수 있기 때문에 런타임에 알고리즘을 변경할 수 있다.
<img width="541" alt="Untitled 3" src="https://github.com/HJC96/Obejct/assets/87226129/36c40e13-15c3-43a5-8c59-95a7c9ce9e25">



물론 변경을 캡슐화하는 방법이 합성만 있는 것은 아니다. 상속을 이용할 수도 있다. 그림 15.5는 Movie의 인터페이스 측면에서는 그림 15.4와 동일하지만 변경을 캡슐화하기 위해 상속을 사용한 예다. 여기서 변하지 않는 부분은 Movie이고 **변하는 부분**은 AmountDiscountPolicy와 PercentDiscountMovie이다. 그리고 **변경하지 않는 부분은 부모 클래스**로, 변하는 부분은 자식 클래스로 분리함으로써 변경을 캡슐화한다. 이처럼 알고리즘을 **캡슐화하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것을 TEMPLATE METHOD 패턴**이라고 부른다.
<img width="691" alt="Untitled 4" src="https://github.com/HJC96/Obejct/assets/87226129/2456267f-666e-42af-bb10-560683fb9391">



추상 클래스나 인터페이스를 사용해 변경을 캡슐화하는 합성과 달리 상속을 사용할 경우에는 추상 메서드를 이용해 변경을 캡슐화해야한다. 그림 15.5에서 claculateDiscountAmount 메서드가 바로 서브클래스의 변경을 캡슐화하기 위해 사용되는 추상 메서드다. 부모 클래스의 calculateFee 메서드 안에서 추상 메서드인 calculateDiscountAmount를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현한다는 것이 중요하다.

이처럼 TEMPLATE METHOD 패턴은 부모 크래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화 할 수 있는 디자인 패턴이다. 다만 합성보다는 결합도가 높은 상속을 사용했기 때문에 STRATEGY 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다. 하짐나 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 STRATEGY 패턴보다 복잡도를 낮출 수 있다는 면에서는 장점이라고 할 수 있다.

그림 15.6의 핸드폰 과금 시스템 설계는 DECORATOR 패턴을 기반으로 한다. DECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로서 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다. DECORATOR 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있다.
<img width="658" alt="Untitled 5" src="https://github.com/HJC96/Obejct/assets/87226129/635ef2be-0439-40d1-8100-e5bee43097d2">



디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.

디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다. 그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.

**패턴은 출발점이다**

- 패턴은 설계의 목표가 돼서는 안된다.
    - 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.
    - 디자인 패턴이 현재의 요구사항이나 적용 기술에 맞지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.
    - 맹목적 패턴 사용 → 패턴 만능주의가 될 수 있으니 조심하자.

## 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

- 설계 재사용
    - 장점: 프로그래밍 언어에 독립적으로 재사용 가능한 설계 아이디어 제공
    - 단점: 언어에 종속적이지 않기에 매번 구현 코드를 재사용 해야함
- 코드 재사용
    - 장점: 별도 프로그래밍 없이 기존 컴포넌트를 조립해서 애플리케이션 구축
    - 단점: 컴포넌트 기반의 재사용 방법은 이상적이지만 비현실적
        - 이유: 프로젝트나 도메인 사이에 비슷한 문제가 별로 없음
- 이상적인 방법
    - 설계 및 코드를 적절한 수준으로 사용 → 프레임워크
    

**프레임 워크 개념**

- 프레임워크의 구조적인 측면
    - 추상 클래스나 인터페이스를 정의하고 인스턴스 사이에 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
- 코드와 설계의 재사용 측면
    - 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격

**프레임워크의 장점** 

설계의 가변성을 미리 정의해 뒀기 때문에 애플리케이션 설계자나 구현자는 애플리케이션에 종속된 부분에 대해서만 설계하면 된다. 

**프레임 워크의 핵심**

추상 클래스나 인터페이스와 같은 **추상화가 프레임 워크의 핵심**이다. 왜냐하면 이 두 가지가 **일관성 있는 협력**을 만드는 핵심 재료이기 때문이다. 협력을 일관성 있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 **캡슐화**해야한다.
<img width="621" alt="Untitled 6" src="https://github.com/HJC96/Obejct/assets/87226129/8a57a9a6-20c4-4cb6-93be-67ac11c713fa">



→ 구체 클래스들은 추상화에 의존하지만 추상화들은 구체 클래스에 의존하지 않는다.

→ 상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다.

→ 또한 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야한다.

→ 이를 해결하는 방법: 의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존시킨다.
<img width="653" alt="Untitled 7" src="https://github.com/HJC96/Obejct/assets/87226129/9baca713-d563-4e12-9324-36964962e0df">



→ 변경으로부터 자유로워 지기 위해 추상화를 경계로 패키지를 분리하여 상위 정책을 구현하고 있는 패키지와 세부 사항을 구현한 패키지를 분리.
<img width="676" alt="Untitled 8" src="https://github.com/HJC96/Obejct/assets/87226129/c69ac194-7946-4f5e-87e9-28a7c2f4498d">



→ 더 나아가 상위 정책과 하위 정책을 분리해 별도의 배포 단위로 만들 수 있다.

→ 추상 클래스와 인터페이스가 가지는 일관성 있는 협력이라는 특징이 프레임워크의 재사용성을 향상시킨다.

**제어 역전 원리**

의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.

- 전통적인 구조
    - 상위 정책의 코드가 하부의 구체적인 코드를 호출한다.
- 객체지향 구조
    - 프레임워크가 어플리케이션에 속하는 서브클래스의 메서드를 호출한다. 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. → 제어 역전 원리

<img width="642" alt="Untitled 9" src="https://github.com/HJC96/Obejct/assets/87226129/641882d4-71e7-4614-af45-ba5d659f8780">


→ 프레임워크의 요소들을 이용해 기본 정책의 협력을 나타낸 것.

여기서 협력을 제어하는 것은 프레임워크다. 즉, 제어가 역전된 것이다. 하지만 이러한 제어의 역전이 프레임워크의 핵심 개념인 동시에 코드의 재사용을 가능하게 하는 힘이다.
